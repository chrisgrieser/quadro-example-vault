/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AiSummaryPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/gpt.ts
var url = "https://api.openai.com/v1/chat/completions";
async function promptGPTChat(prompt, apiKey, maxTokens, dialog) {
  var _a;
  const requestOptions = {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`
    },
    body: JSON.stringify({
      "messages": [{ "role": "system", "content": prompt }],
      model: "gpt-3.5-turbo",
      temperature: 0.7,
      max_tokens: maxTokens,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      stream: true
    })
  };
  const response = await fetch(url, requestOptions);
  const reader = (_a = response.body) == null ? void 0 : _a.pipeThrough(new TextDecoderStream()).getReader();
  let content = "";
  let gotDoneMessage = false;
  while (true) {
    const res = await (reader == null ? void 0 : reader.read());
    if (res == null ? void 0 : res.done)
      break;
    if (!(res == null ? void 0 : res.value))
      continue;
    const text = res == null ? void 0 : res.value;
    const lines = text.split("\n").filter((line) => line.trim() !== "");
    for (const line of lines) {
      const lineMessage = line.replace(/^data: /, "");
      if (lineMessage === "[DONE]") {
        gotDoneMessage = true;
        break;
      }
      try {
        const parsed = JSON.parse(lineMessage);
        const token = parsed.choices[0].delta.content;
        if (token) {
          dialog.addContent(token);
          content += token;
        }
      } catch (error) {
        console.error(`Could not JSON parse stream message`, {
          text,
          lines,
          line,
          lineMessage,
          error
        });
      }
    }
  }
  return content;
}

// src/ui/result_dialog.ts
var import_obsidian = require("obsidian");
var ResultDialog = class extends import_obsidian.Modal {
  constructor(app) {
    super(app);
  }
  addContent(text) {
    this.text.setText(this.text.getText() + text);
  }
  onOpen() {
    const { contentEl } = this;
    const container = contentEl.createEl("div", {
      cls: "ai-summary-container"
    });
    this.text = container.createEl("textarea", { cls: "ai-summary-textarea" });
    this.text.placeholder = "...";
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var defaultMaxTokens = 2e3;
var DEFAULT_SETTINGS = {
  openAiApiKey: "",
  maxTokens: defaultMaxTokens,
  defaultPrompt: "Write me a 2-3 paragraph summary of this in the first person."
};
var AiSummaryPlugin = class extends import_obsidian2.Plugin {
  async generateSummary() {
    var _a;
    const dialog = new ResultDialog(this.app);
    dialog.open();
    const { vault } = this.app;
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    const file = markdownView == null ? void 0 : markdownView.file;
    if (!file)
      return "No note open.";
    const content = await vault.cachedRead(file);
    const frontMatter = this.extractFrontmatter(content);
    const referencedNotes = await this.getReferencedContent(content, file);
    if (!referencedNotes || referencedNotes.length === 0) {
      dialog.addContent("No referenced notes found.");
      return "No referenced notes found.";
    }
    await promptGPTChat(this.generateGPTPrompt(referencedNotes, (_a = frontMatter["prompt"]) != null ? _a : this.settings.defaultPrompt), this.settings.openAiApiKey, this.settings.maxTokens, dialog);
    return "Summary written.";
  }
  hasOpenNote() {
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    return !!(markdownView == null ? void 0 : markdownView.file);
  }
  generateGPTPrompt(notes, queryPrompt) {
    let prompt = "";
    for (const note of notes) {
      prompt += note;
      prompt += "----";
    }
    return prompt + queryPrompt;
  }
  async getReferencedContent(content, currentFile) {
    const referencedNotes = [];
    const lines = content.split("\n");
    for (const line of lines) {
      if (line.includes("[[") && line.includes("]]")) {
        const links = this.extractTextBetweenBrackets(line);
        for (const link of links) {
          const noteLink = this.app.metadataCache.getFirstLinkpathDest(link, currentFile.path);
          referencedNotes.push(await this.readContents(noteLink));
        }
      }
    }
    return referencedNotes;
  }
  async readContents(note) {
    if (note) {
      return await this.app.vault.read(note);
    }
    return "";
  }
  extractTextBetweenBrackets(str) {
    const regex = /\[\[([\s\S]*?)\]\]/g;
    const matches = [];
    let match;
    while ((match = regex.exec(str)) !== null) {
      matches.push(match[1]);
    }
    return matches;
  }
  extractFrontmatter(md) {
    const frontmatterRegex = /^---\n([\s\S]*?)\n---\n/;
    const match = md.match(frontmatterRegex);
    const frontmatter = {};
    if (match) {
      const frontmatterString = match[1];
      const frontmatterLines = frontmatterString.split("\n");
      frontmatterLines.forEach((line) => {
        const [key, value] = line.split(":").map((item) => item.trim());
        frontmatter[key.toLowerCase()] = value;
      });
    }
    return frontmatter;
  }
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("pencil", "Summarize referenced notes", async () => {
      const resultSummary = await this.generateSummary();
      new import_obsidian2.Notice(resultSummary);
    });
    this.addCommand({
      id: "ai-summary",
      name: "Summarize referenced notes",
      checkCallback: (checking) => {
        if (checking) {
          return this.hasOpenNote();
        }
        (async () => {
          new import_obsidian2.Notice(await this.generateSummary());
        })();
      }
    });
    this.addSettingTab(new AiSummarySettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var AiSummarySettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for the AI Summary Plugin." });
    new import_obsidian2.Setting(containerEl).setName("OpenAI API Key").setDesc("OpenAI API Key").addText((text) => text.setPlaceholder("API Key").setValue(this.plugin.settings.openAiApiKey).onChange(async (value) => {
      this.plugin.settings.openAiApiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Max tokens").setDesc("Max tokens").addText((text) => {
      var _a;
      return text.setPlaceholder(defaultMaxTokens.toString()).setValue(((_a = this.plugin.settings.maxTokens) == null ? void 0 : _a.toString()) || defaultMaxTokens.toString()).onChange(async (value) => {
        this.plugin.settings.maxTokens = Number.parseInt(value);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Default prompt").setDesc("Default prompt").addTextArea((text) => text.setPlaceholder("Prompt").setValue(this.plugin.settings.defaultPrompt).onChange(async (value) => {
      this.plugin.settings.defaultPrompt = value;
      await this.plugin.saveSettings();
    }));
  }
};
